"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[764],{4672:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=n(5250),s=n(1340);const o={sidebar_position:3},a="Magic mutation fields",r={id:"magic-mutation-fields",title:"Magic mutation fields",description:"Schema extensions",source:"@site/docs/magic-mutation-fields.md",sourceDirName:".",slug:"/magic-mutation-fields",permalink:"/docs/magic-mutation-fields",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Quickstart guide",permalink:"/docs/quickstart"},next:{title:"The Isograph config",permalink:"/docs/isograph-config"}},l={},d=[{value:"Schema extensions",id:"schema-extensions",level:2},{value:"Magic mutation fields",id:"magic-mutation-fields-1",level:2},{value:"How do we create a magic mutation field?",id:"how-do-we-create-a-magic-mutation-field",level:2},{value:"How do we use this field?",id:"how-do-we-use-this-field",level:2},{value:"We&#39;re just modifying the tagline! Why refetch the entire Pet?",id:"were-just-modifying-the-tagline-why-refetch-the-entire-pet",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"magic-mutation-fields",children:"Magic mutation fields"}),"\n",(0,i.jsx)(t.h2,{id:"schema-extensions",children:"Schema extensions"}),"\n",(0,i.jsxs)(t.p,{children:["You can include a ",(0,i.jsx)(t.code,{children:"schema_extensions"})," field in your ",(0,i.jsx)(t.code,{children:"isograph.config.json"})," file. It's value should be an array of schema extension files."]}),"\n",(0,i.jsx)(t.p,{children:"If the source of truth for your schema is not the repository where you use Isograph (e.g. it is imported from elsewhere, or it is generated, etc.), you may find it easier to work with a schema extension. That is what we will do in this guide."}),"\n",(0,i.jsx)(t.h2,{id:"magic-mutation-fields-1",children:"Magic mutation fields"}),"\n",(0,i.jsxs)(t.p,{children:["A mutation often has a primary object that is modified. For example, a ",(0,i.jsx)(t.code,{children:"setUserProperties"})," mutation might modify a user, and return the updated user."]}),"\n",(0,i.jsxs)(t.p,{children:["In Isograph, you can select that ",(0,i.jsx)(t.code,{children:"setUserProperties"})," mutation directly off of a ",(0,i.jsx)(t.code,{children:"User"})," object. This has several advantages:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"it's convenient! You'll often need user fields (e.g. the user's name) in the screen that modifies the user."}),"\n",(0,i.jsx)(t.li,{children:"since we know which user you're mutating, you don't have to pass the user's ID as a mutation parameter"}),"\n",(0,i.jsx)(t.li,{children:"since the compiler knows what fields you fetched on that user, you can refetch those exact same fields in the mutation response!"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"how-do-we-create-a-magic-mutation-field",children:"How do we create a magic mutation field?"}),"\n",(0,i.jsx)(t.p,{children:"Let's assume that we have a schema containing the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-graphql",children:"type Mutation {\n  set_pet_tagline(input: SetPetTaglineParams!): SetPetTaglineResponse!\n}\n\ninput SetPetTaglineParams {\n  id: ID!\n  tagline: String!\n}\n\ntype SetPetTaglineResponse {\n  pet: Pet!\n}\n\ntype Pet {\n  id: ID!\n  tagline: String\n  # other fields\n}\n"})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["The schema in the ",(0,i.jsx)(t.a,{href:"https://github.com/isographlabs/isograph/tree/main/demos/graphql-conf-2023-demo",children:(0,i.jsx)(t.code,{children:"demos/graphql-conf-2023-demo"})})," is like this."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We can add an ",(0,i.jsx)(t.code,{children:"@exposeField"})," directive to the ",(0,i.jsx)(t.code,{children:"Mutation"})," object to expose a magic mutation field as follows, by putting the following in our ",(0,i.jsx)(t.code,{children:"schema-extension.graphql"})," file:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-graphql",children:'extend type Mutation\n  @exposeField(\n    field: "set_pet_tagline"\n    path: "pet"\n    field_map: [{ from: "id", to: "input.id" }]\n  )\n'})}),"\n",(0,i.jsx)(t.p,{children:"Let's go through each of these parameters in turn."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"field"})," this is the field on the ",(0,i.jsx)(t.code,{children:"Mutation"})," object that we want to expose."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"path"})," this is the path in the mutation field's response object to the parent object, ",(0,i.jsx)(t.strong,{children:"on which we want to expose the field"}),". So, ",(0,i.jsx)(t.code,{children:"SetPetTaglineResponse.pet"})," gets us a ",(0,i.jsx)(t.code,{children:"Pet"})," object, so each ",(0,i.jsx)(t.code,{children:"Pet"})," will have the magic mutation field added."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"field_map"}),": this is an array of ",(0,i.jsx)(t.code,{children:"from"})," and ",(0,i.jsx)(t.code,{children:"to"})," values, that maps fields ",(0,i.jsx)(t.strong,{children:"from"})," the ",(0,i.jsx)(t.code,{children:"Pet"})," ",(0,i.jsx)(t.strong,{children:"to"})," the mutation field params. So, we are mapping ",(0,i.jsx)(t.code,{children:"Pet.id"})," to the ",(0,i.jsx)(t.code,{children:"id"})," field of the ",(0,i.jsx)(t.code,{children:"input"})," param of the ",(0,i.jsx)(t.code,{children:"set_pet_tagline"})," field.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["since this field is provided, this means that the user must provide something that looks like ",(0,i.jsx)(t.code,{children:"{ input: { tagline } }"}),", and Isograph fills in the rest."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"how-do-we-use-this-field",children:"How do we use this field?"}),"\n",(0,i.jsxs)(t.p,{children:["Now, this field (prefixed with two underscores) is available on the ",(0,i.jsx)(t.code,{children:"Pet"})," object. (This prefix will be removed, and the exposed field name will be customizable.)"]}),"\n",(0,i.jsx)(t.p,{children:"You might select it like"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"export const pet_tagline_input = iso<\n  PetUpdaterParams,\n  ReturnType<typeof PetUpdater>\n>`\n  Pet.pet_tagline_input @component {\n    __set_pet_tagline,\n    tagline,\n  }\n`(PetTaglineInput);\n"})}),"\n",(0,i.jsx)(t.p,{children:"When read out, the field is a function that when called, makes a network request for the mutation. (Also, in the future, you will be able to do things like get the status of the mutation, suspend on it, etc. For now, it just triggers a mutation in the background.)"}),"\n",(0,i.jsx)(t.p,{children:"You might use it as follows:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:'function PetUpdater(props: PetUpdaterParams) {\n  const [tagline, setTagline] = useState<string>(props.data.tagline);\n\n  const updateTagline = () =>\n    props.data.__set_pet_tagline({ input: { tagline } });\n\n  return (\n    <>\n      <Input\n        value={tagline}\n        onChange={(e) => setTagline(e.target.value)}\n        color="primary"\n        onKeyDown={(e) => {\n          if (e.key === "Enter") {\n            updateTagline();\n          }\n        }}\n      />\n      <Button variant="contained" onClick={updateTagline}>\n        Set tagline\n      </Button>\n    </>\n  );\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The fields selected on the mutation response (under the pet) will be ",(0,i.jsx)(t.strong,{children:"exactly the fields that are selected on that Pet in the merged query"}),". In other words, it will contain ",(0,i.jsx)(t.code,{children:"tagline"})," (because that is selected in ",(0,i.jsx)(t.code,{children:"Pet.pet_tagline_input"}),"), ",(0,i.jsx)(t.code,{children:"id"})," (because that is auto-selected by Isograph) and any other fields that are selected by resolvers on the same pet in the same query."]}),"\n",(0,i.jsxs)(t.p,{children:["You can view the generated mutation query by looking for a file whose name starts with ",(0,i.jsx)(t.code,{children:"__refetch__"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"were-just-modifying-the-tagline-why-refetch-the-entire-pet",children:"We're just modifying the tagline! Why refetch the entire Pet?"}),"\n",(0,i.jsx)(t.p,{children:"A future version of Isograph will support this!"})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1340:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>a});var i=n(79);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);