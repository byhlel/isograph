"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[836],{9672:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var o=t(5250),r=t(1340);const s={sidebar_position:5},i="FAQ",c={id:"faq",title:"FAQ",description:"Why do @component resolvers need to be interpolated into the parent, and not rendered?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"The Isograph config",permalink:"/docs/isograph-config"},next:{title:"Backlog",permalink:"/docs/backlog"}},a={},d=[{value:"Why do <code>@component</code> resolvers need to be interpolated into the parent, and not rendered?",id:"why-do-component-resolvers-need-to-be-interpolated-into-the-parent-and-not-rendered",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"faq",children:"FAQ"}),"\n",(0,o.jsxs)(n.h2,{id:"why-do-component-resolvers-need-to-be-interpolated-into-the-parent-and-not-rendered",children:["Why do ",(0,o.jsx)(n.code,{children:"@component"})," resolvers need to be interpolated into the parent, and not rendered?"]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.p,{children:"This answer will soon be out-of-date. Proper component support is coming at some point."})}),"\n",(0,o.jsx)(n.p,{children:"Consider a parent component that fetches a child component. The child component should be interpolated into the returned JSX:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export const parent_component = iso`\n  Query.parent_component @component {\n    child_component,\n  }\n`(function ParentComponent({ data }) {\n  // THIS IS CORRECT:\n  return (\n    <>\n      Parent component\n      {child_component({})}\n    </>\n  );\n  // AND THIS IS NOT:\n  // return <>\n  //   Parent component\n  //   <child_component />\n  // </>\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This is because the ",(0,o.jsx)(n.code,{children:"child_component"})," function is ",(0,o.jsx)(n.strong,{children:"not"})," referentially stable. In particular, every time ",(0,o.jsx)(n.code,{children:"data"})," changes, the component would have to lose its state. However, the value returned from ",(0,o.jsx)(n.code,{children:"child_component({})"})," ",(0,o.jsx)(n.strong,{children:"is"})," an element whose component is referentially stable, meaning that the component will not lose its state when data changes, and thus ",(0,o.jsx)(n.strong,{children:"de facto"})," is indistinguishable from a regular component."]}),"\n",(0,o.jsxs)(n.p,{children:["In the React DevTools component viewer, you can see all ",(0,o.jsx)(n.code,{children:"@component"})," resolvers that are rendered."]})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1340:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>i});var o=t(79);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);