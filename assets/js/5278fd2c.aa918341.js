"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[846],{6795:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});var l=i(5250),s=i(1340);const r={sidebar_position:999},t="Backlog",o={id:"backlog",title:"Backlog",description:"Top QOL priorities",source:"@site/docs/backlog.md",sourceDirName:".",slug:"/backlog",permalink:"/docs/backlog",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:999,frontMatter:{sidebar_position:999},sidebar:"tutorialSidebar",previous:{title:"FAQ",permalink:"/docs/faq"}},c={},a=[{value:"Top QOL priorities",id:"top-qol-priorities",level:2},{value:"V2 release",id:"v2-release",level:2},{value:"Feature backlog",id:"feature-backlog",level:2},{value:"Cleanup backlog",id:"cleanup-backlog",level:2},{value:"Known bugs",id:"known-bugs",level:2},{value:"Extended backlog",id:"extended-backlog",level:2}];function d(e){const n={code:"code",del:"del",h1:"h1",h2:"h2",li:"li",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h1,{id:"backlog",children:"Backlog"}),"\n",(0,l.jsx)(n.h2,{id:"top-qol-priorities",children:"Top QOL priorities"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["rethink iso syntax","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Consider combining isoFetch and iso, as in ",(0,l.jsx)(n.code,{children:"iso`entrypoint Query.home_page` "})," or the like"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"publish isograph.dev (via gh-pages?)"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"v2-release",children:"V2 release"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:['components and "realized" resolvers, as well as ways to invalidate them',"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"they could also be lazily calculated"}),"\n",(0,l.jsx)(n.li,{children:"may require garbage collection"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"iso overload in files"}),"\n",(0,l.jsx)(n.li,{children:"cleanup types"}),"\n",(0,l.jsx)(n.li,{children:"error handling"}),"\n",(0,l.jsx)(n.li,{children:"validate no unknown directives left over"}),"\n",(0,l.jsxs)(n.li,{children:["exposeAs as param","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"use serde for this?"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Handle unions etc. correctly"}),"\n",(0,l.jsx)(n.li,{children:"Special fields (or syntax?) for type casts (i.e. type refinement)"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"feature-backlog",children:"Feature backlog"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"garbage collection"}),"\n",(0,l.jsx)(n.li,{children:"granular re-rendering"}),"\n",(0,l.jsx)(n.li,{children:"fetch policies"}),"\n",(0,l.jsxs)(n.li,{children:["Unwraps (i.e. ",(0,l.jsx)(n.code,{children:"!"}),") exist in the syntax, but are unused","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:'consider whether it is truly the case that there always is a linear way to unwrap a given field, or whether we should unify this with "execute this on the server" etc.'}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Resolvers are re-calculated every time. They should be cached in the store."}),"\n",(0,l.jsx)(n.li,{children:"The store, etc. should be stored in context."}),"\n",(0,l.jsx)(n.li,{children:"Resolvers return opaque objects and cannot be selected into. They should be extended to also allow the return of IDs, which can then be selected into."}),"\n",(0,l.jsxs)(n.li,{children:["Stateful resolvers?","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:'This could be thought of as "realized" resolvers, which is to say there is overlap with better DevEx for components'}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Subscriptions are not supported"}),"\n",(0,l.jsx)(n.li,{children:"Defer, etc."}),"\n",(0,l.jsx)(n.li,{children:"Pagination."}),"\n",(0,l.jsx)(n.li,{children:"Types for variables"}),"\n",(0,l.jsx)(n.li,{children:"Inferred types for iso params w/iso overload"}),"\n",(0,l.jsx)(n.li,{children:"typed IDs"}),"\n",(0,l.jsx)(n.li,{children:"special fetch fields"}),"\n",(0,l.jsxs)(n.li,{children:["consider resolvers that return functions only read data when called, i.e. do not eagerly read. Consider whether this can be achieved with omitting a !, i.e. foo_resolver! returns TReadFromStore, foo_resolver returns a ",(0,l.jsx)(n.code,{children:"ReadDataResult TReadFromStore"})]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"cleanup-backlog",children:"Cleanup backlog"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Typegen code is a mess"}),"\n",(0,l.jsx)(n.li,{children:"JS code needs structure, etc."}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"HACK__merge_linked_fields"})," is indicative of the fact that merged linked fields should contain hashmaps of key => merged item, instead of vectors of merged items."]}),"\n",(0,l.jsxs)(n.li,{children:["Objects which do not have IDs should be merged into their parent object in the store.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"or weak types are scalars"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Remove the requirement that arguments and parameters have a terminal comma."}),"\n",(0,l.jsxs)(n.li,{children:["IsographSchemaObject, etc. should not contain name: ",(0,l.jsx)(n.code,{children:"WithLocation<...>"}),", but instead, be stored ",(0,l.jsx)(n.code,{children:"WithLocation T"}),", and WithLocation should ",(0,l.jsx)(n.strong,{children:"not"})," have a span."]}),"\n",(0,l.jsx)(n.li,{children:"There should be a cleaner separation between GraphQL and Isograph. In particular, we should load the GraphQL schema, but turn it into Isograph concepts, and only deal with Isograph concepts."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"known-bugs",children:"Known bugs"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"If a useLazyReference commits then receives new props, it does not make a new network request."}),"\n",(0,l.jsxs)(n.li,{children:["if mutation primary field has a non-existent type, we panic, this should be an error","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"this is because we add the fields before we call Schema::validate_and_construct, where the error would naturally be found."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:'incorrect spans for errors e.g. "Message: The id field on "Pet" must be "ID!"."'}),"\n",(0,l.jsx)(n.li,{children:"error parsing config should not panic, but be a diagnostic"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"extended-backlog",children:"Extended backlog"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Docs"}),"\n",(0,l.jsx)(n.li,{children:"VSCode extension"}),"\n",(0,l.jsx)(n.li,{children:"Fetch policies"}),"\n",(0,l.jsx)(n.li,{children:"Garbage collection"}),"\n",(0,l.jsx)(n.li,{children:"Preloaded queries"}),"\n",(0,l.jsx)(n.li,{children:"Fetch/cache policies"}),"\n",(0,l.jsx)(n.li,{children:"Granular re-renders"}),"\n",(0,l.jsx)(n.li,{children:"Traditional refetch fields"}),"\n",(0,l.jsx)(n.li,{children:"Defer/stream"}),"\n",(0,l.jsx)(n.li,{children:"Subscriptions"}),"\n",(0,l.jsx)(n.li,{children:"Interfaces/unions"}),"\n",(0,l.jsxs)(n.li,{children:["Entrypoints","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Directives on isoFetch"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Field unwrapping syntax"}),"\n",(0,l.jsx)(n.li,{children:"Pagination"}),"\n",(0,l.jsx)(n.li,{children:"Refetch on missing data"}),"\n",(0,l.jsx)(n.li,{children:"Compile to non-GraphQL"}),"\n",(0,l.jsx)(n.li,{children:"Actually validate variables"}),"\n",(0,l.jsx)(n.li,{children:"Persisted queries"}),"\n",(0,l.jsxs)(n.li,{children:["Suspense/response for mutations/refetch","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"this probably means we need mutations to be part of a stateful component"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Strongly typed ID fields"}),"\n",(0,l.jsxs)(n.li,{children:["Custom normalizers","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Garbage collection for custom normalizers by type"}),"\n",(0,l.jsx)(n.li,{children:'other "by type" things?'}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Lazy normalization ASTs"}),"\n",(0,l.jsx)(n.li,{children:"Fetching off of typed IDs"}),"\n",(0,l.jsx)(n.li,{children:"Stateful resolvers"}),"\n",(0,l.jsxs)(n.li,{children:["Compiler executable for ",(0,l.jsx)(n.del,{children:"Mac"}),"/Windows/Linux"]}),"\n",(0,l.jsx)(n.li,{children:"Unit tests"}),"\n",(0,l.jsx)(n.li,{children:"E2E tests"}),"\n",(0,l.jsx)(n.li,{children:"Network request errors"}),"\n",(0,l.jsx)(n.li,{children:"Proper missing field handlers"}),"\n",(0,l.jsx)(n.li,{children:"Missing field handlers from schema definitions/directives"}),"\n",(0,l.jsx)(n.li,{children:"Store held in context"}),"\n",(0,l.jsx)(n.li,{children:"Imperative store APIs"}),"\n",(0,l.jsx)(n.li,{children:"Typesafe updaters"}),"\n",(0,l.jsx)(n.li,{children:"Sample router integration"}),"\n",(0,l.jsx)(n.li,{children:"Emit new field definitions for GraphiQL and other tools (!!!)"}),"\n",(0,l.jsx)(n.li,{children:"Field groups"}),"\n",(0,l.jsxs)(n.li,{children:["Lint rules to enforce ",(0,l.jsx)(n.code,{children:"export const"})," (or compiler support)"]}),"\n",(0,l.jsx)(n.li,{children:"Guide for testing Isograph components"}),"\n",(0,l.jsxs)(n.li,{children:["Support non-globally unique IDs","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"@strong directive"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Iso lang code mods"}),"\n",(0,l.jsx)(n.li,{children:"Iso lang syntax highlighting"}),"\n",(0,l.jsx)(n.li,{children:"Iso lang auto-format"}),"\n",(0,l.jsx)(n.li,{children:"Separate artifacts for fetching, normalizing and reading fetchable resolvers"}),"\n",(0,l.jsx)(n.li,{children:"Incremental compilation"}),"\n",(0,l.jsx)(n.li,{children:"Saved state"}),"\n",(0,l.jsx)(n.li,{children:"Support strict mode?"}),"\n",(0,l.jsx)(n.li,{children:"Load resolvers iff needed"}),"\n",(0,l.jsx)(n.li,{children:"Object literals as variables"}),"\n",(0,l.jsx)(n.li,{children:"Server support for JSResource"}),"\n",(0,l.jsx)(n.li,{children:"Injectable code for @component"}),"\n",(0,l.jsx)(n.li,{children:"Isograph dev tools"}),"\n",(0,l.jsx)(n.li,{children:"Experiment with context and JSX for @component"}),"\n",(0,l.jsx)(n.li,{children:"Vue/Svelte/etc. integration"}),"\n",(0,l.jsx)(n.li,{children:"Compile compiler to Wasm"}),"\n",(0,l.jsx)(n.li,{children:"IR explorer"}),"\n",(0,l.jsx)(n.li,{children:"Code sandbox example"}),"\n",(0,l.jsx)(n.li,{children:"Topological sort in compiler"}),"\n",(0,l.jsx)(n.li,{children:"Validate no infinite recursion"}),"\n",(0,l.jsx)(n.li,{children:"Statically prune inaccessible branches"}),"\n",(0,l.jsx)(n.li,{children:"TypeScript errors in emitted artifacts"}),"\n",(0,l.jsx)(n.li,{children:"Better repr. of nullable types in compiler"}),"\n",(0,l.jsx)(n.li,{children:"Babel integration for iso literal values"}),"\n",(0,l.jsx)(n.li,{children:"Typescript integration for type inference of iso literals"}),"\n",(0,l.jsx)(n.li,{children:"Parallelize artifact gen"}),"\n",(0,l.jsx)(n.li,{children:"Rationalize WithSpan vs WithLocation"}),"\n",(0,l.jsxs)(n.li,{children:["Display multiple errors, parse etc. in parallel","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Multiple errors when parsing the schema (is this possible??)"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Do not look in artifact_directory, if project_root contains artifact_directory"}),"\n",(0,l.jsxs)(n.li,{children:["Do not require that the exported name of an iso is anything in particular.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Can we make the transform add an export if none is found?? Probably!"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"SWC plugin"}),"\n",(0,l.jsx)(n.li,{children:"plugin options to point to config"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},1340:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>t});var l=i(79);const s={},r=l.createContext(s);function t(e){const n=l.useContext(r);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),l.createElement(r.Provider,{value:n},e.children)}}}]);